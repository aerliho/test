#安全观
安全问题是一个信任的问题，一切的安全方案设计的基础，都是建立在信任关系上的。
我们必须相信一些东西，必须有一些最基本的假设，安全方案才能得以建立；如果我们否定一切，安全方案也无法完成。

同时，安全也是一个持续的过程，在解决安全问题的过程中，不可能一劳永逸，因为攻击和防御技术一直在发展。


##安全三要素
- 机密性，要求被保护数据内容不能泄露。加密是实现机密性的常见手段。
- 完整性，要求被保护数据内容是完整、没有被篡改的。常见的技术手段是数字签名。
- 可用性，要求被保护资源是“随需而得”的。拒绝服务攻击（DoS）破坏的是安全的可用性。

在安全领域中，最重要的要素就是这三个，在设计安全方案时，要以这三个要素为基本出发点，全面的考虑所面对的问题。


##安全评估
一个安全评估的过程，可以简单的分为4个阶段：资产等级划分、威胁分析、风险分析、确认解决方案。
###资产等级划分
互联网安全的核心问题是数据安全问题。
资产等级划分也就是对数据作等级划分。做资产等级划分的过程，需要与各业务部门负责人沟通，了解公司最重要的财产是什么，他们最看重的数据是什么。
当完成资产等级划分后，对要保护的目标有了大概的了解，接下来就要划分信任域和信任边界了。
通常我们用一种最简单的划分方式，就是从网络逻辑上来划分。比如最重要的数据放在数据库里，那么把数据库的服务圈起来；
web应用可以从数据库中读/写数据，并对外提供服务，再把web服务圈起来；最外边是不可信任的internet。
###威胁分析
在安全领域里，把能造成危险的来源称为威胁（Threat)，把可能出现的损失称为风险。风险一定是和损失联系在一起的，把可能出现的损失称为风险。风险一定是和损失联系在一起的。
威胁分析就是把所有的威胁找出来。一般是采用头脑风暴法，也有一些比较科学的方法，比如使用威胁模型。
STRIDE模型，是最早由微软提出的，是几个单词的缩写，我们在分析威胁时可以从这些方面去考虑。
这是模型的具体定义。
###风险分析
可能存在很多威胁，但宾菲每个威胁都会造成难以承受的损失。一个威胁到底能造成大的危害，如何去衡量它？就要考虑到风险了。
我们判断风险高低的过程，就是风险分析的过程。
风险由以下因素组成：Risk = Probability * Damage Potential
风险分析也有模型，DREAD模型，也是微软提出的。
这里是定义。

类似的模型很多，不同的标准会对应不同的模型，只要我们觉得这些模型是科学的，能够帮助我们，就可以使用。
但模型只能祈祷一个辅助作用，最终做决策的还是人。
##设计安全方案
安全评估的产物，就是安全解决方案。
一个好的安全模块，同时也应该是一个优秀的程序，从设计上需要做到高聚合、低耦合、易于扩展。
最终一个优秀的安全方案应该具备以下特点：
- 能够有效解决问题
- 用户体验好
- 高性能
- 低耦合
- 易于扩展和升级


##白帽子兵法
###Secure By Default原则
- 黑名单、白名单

白名单比黑名单更安全，但并不是用了白名单就一定安全了。

- 最小权限原则

最小权限原则要求系统只授予主体必要的权限，而不要过度授权，这样能有效的减少系统、网络、应用、数据库出错的机会。

###纵深防御原则
纵深防御包含两层含义：
首先，要在各个不同层面、不同方面实施安全方案，避免出现疏漏，在不同安全方案之间需要互相配合构成一个整体；
其次，要在正确的地方做正确的事情，即：在解决根本问题的地方实施针对性的安全方案。 

就入侵防御来说，我们需要考虑的可能有web应用安全、os系统安全、数据库安全、网络环境安全等。

###数据与代码分离原则
另一个安全原则是数据与代码分离原则。这一原则广泛适用于各种犹豫“注入”而引发的安全问题的场景。

###不可预测原则
前边介绍的几条原则：Secure By Default是时刻要牢记的总则；纵深防御，是要更全面、更正确的看待问题；数据与代码分离，是从漏洞成因上看问题；
接下来要讲的“不可预测性”原则，则是从克服攻击方法的角度看问题。
不可预测原则，可以巧妙的用在一些敏感数据上。
不可预测性的实现往往需要用到加密算法、随机数算法、哈希算法，好好使用这条原则，在设计安全方案时往往会事半功倍。

#浏览器安全

##同源策略

同源策略是一种约定，它是浏览器最核心也是最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能呢可能会受到影响。
浏览器的同源策略，限制了来自不同源的“document”或脚本，对当前的“document”读取或设置某些属性。
影响源的因素有：host（域名或IP地址，如果是IP则看作是一个根域名）、子域名、端口、协议。
需要注意的是，对于当前页面来说，页面内存放javascript文件的域并不重要，重要的是加载javascript页面所在的域是什么。
例子。


#跨站脚本（XSS）攻击

##简介
跨站脚本攻击，英文全称是Cross Site Script，本来缩写是CSS，但是为了和层叠样式表有所区别，所以在安全领域叫做“XSS”。
XSS攻击，通常指黑客通过“HTML注入”篡改了网页，插入恶意的脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击。
在一开始，这种攻击的演示示例是跨域的，所以叫做“跨站脚本”。
但发展到今天，由于javascript的强大功能以及网站前端应用的复杂化，是否跨域已经不再重要。
但是由于历史原因，XSS这名字一直保留了下来。

例子。

XXS根据效果的不同可以分成几类：
- 反射型XSS

反射性XSS只是简单的把用户输入的数据“反射”给浏览器。
也就是说，黑客往往需要诱使用户“点击”一个而已链接，才能攻击成功。反射型XSS也叫做“非持久型XSS”。

- 存储型XSS

存储型XSS会吧用户输入的数据“存储“到服务器端。这种XSS具有很强的稳定性。
比较常见的一个场景就是，黑客写下一片包含有而已javascript代码的博客，文章发表后，所有访问该博客文章的用户，都会在他们的浏览器中执行这段恶意的javascript代码。
黑客把恶意的脚本保存到服务器端，所以这种XSS攻击叫做“存储型XSS”。
存储型XSS通常也叫做“持久型XSS”，因为从效果上来说，它的存在时间比较长。

- DOM Based XSS

实际上，这种类型的XSS并非按照“数据是否保存在服务器端”来划分的，它从效果上来说也是反射型XSS。
单独划分出来，是因为DOM Based XSS的形成原因比较特别，发现它的安全专家专门提出了这种类型的XSS。
出于历史原因，也就把它单独作为一个分类了。
通过修改页面的DOM节点形成的XSS，称之为DOM Based XSS。

##攻击
###XSS Payload
前文谈到了XSS的几种分类。接下来，就从攻击的角度来体验一下XSS的威力。
XSS攻击成功后，攻击者能够对用户当前浏览器的页面植入恶意脚本，通过恶意脚本，控制用户的浏览器。
这些用以完成各种具体功能的恶意脚本，被称为“XSS Payload”。
一个最常见的XSS Payload，就是通过读取浏览器的Cookie对象，从而发起“Cookie劫持”攻击。
Cookie中一般加密保存了当前用户的登录凭证。Cookie如果丢失，往往意味着用户的登录凭证丢失。
换句话说，攻击者可以不通过密码，而直接登录进用户的账户。
例子。

###强大的XSS Payload
“Cookie劫持”并非所有的时候都会有效。
有的网站可能会在Set-Cookie时给关键Cookie植入HttpOnly标识，有的网站可能会吧Cookie与客户端IP绑定，从而使得XSS窃取的Cookie失去意义。
尽管如此，在XSS攻击成功后，攻击者仍然有许多方式能控制用户的浏览器。
- 构造GET与POST请求
- XSS钓鱼
- 识别用户浏览器
- 识别用户安装的软件
- CSS History Hack
- 获取用户的真实IP地址

###XSS攻击平台（略）

###XSS Worm
XSS Worm是XSS的一种终极利用方式，它的破坏力和影响力是巨大的。但是发起XSS Worm攻击也有一定的条件。
一般来说，用户之间发生交互行为的页面，如果存在存储型XSS，则比较容易发起XSS Worm攻击。
比如发送站内信、用户留言等页面，都是XSS Worm的高发区，需要重点关注。
而相对的，如果一个页面只能由用户个人查看，比如“用户个人资料设置”页面，因为缺乏用户之间的互动功能，所以即使存在XSS，也不能被用于XSS Worm的传播。

例子。

###调试javascript（略）

###XSS构造技巧
- 利用字符编码
- 绕过长度限制
- 使用base标签
- window.name的妙用

###变废为宝（略）

###Flash XSS
前文提到的XSS攻击都是基于HTML的，其实Flash中同样也可能造成XSS攻击。
在flahs中是可以嵌入ActionScript脚本的。
ActionScript是一种强大和灵活的脚本，甚至可以使用它发起网络连接，因此应该尽可能的禁止用户能够上传或加载自定义的flash文件。
由于flash文件如此危险，所以在实现XSS Filter时，一般都会禁用embed、object等标签。后者甚至可以加载ActiveX控件，能够产生更为严重的后果。

如果网站的引用 一定要用flash，一般来说，如果是视频文件，则需要转码为“flv文件”。
flv文件是静态文件，不会产生安全隐患。
如果是带动态脚本的flash，则可以通过flash的配置参数进行限制。

###javascript开发框架（略）

##防御
###HttpOnly
HttpOnly最早是由微软提出的，并在IE6中实现的，至今已经逐渐成为一个标准。
浏览器将禁止页面的javascript访问带有HttpOnly属性的cookie。
严格的说，HttpOnly并非为了对抗XSS，HttpOnly解决的是XSS后的cookie劫持攻击。

一个cookie的使用过程如下：
1. 浏览器向服务器发起请求，这时候没有cookie。
2. 服务器返回时发送Set-Cookie头，向客户端浏览器写入Cookie。
3. 在该Cookie到期前，浏览器访问该域下的所有页面，都将发送该Cookie。

HttpOnly是在Set-Cookie时标记的。
某些时候，应用可能需要javascript访问某些Cookie，这种Cookie可以不设置HttpOnly标记，而仅把HttpOnly标记给用于认证的关键Cookie。
使用HttpOnly有助于缓解XSS攻击，但仍然需要其他能够解决XSS漏洞的方案。

###输入检查
常见的Web漏洞如XSS、SQL Injection等，都需要攻击者构造一些特殊字符，这些特殊字符可能是正常用户不会用到的，所以输入检查就有存在的必要了。
输入检查的逻辑，必须放在服务器端代码中实现。如果只是在客户端使用javascript进行输入检查，是很容易被攻击者绕过的。目前web开发的普遍做法，是同时在客户端javascript和服务器端中实现相同的输入检查。
客户端javascript的输入检查，可以阻挡大部分误操作的正常用户，从而节约服务器资源。
在XSS防御上，输入检查一般是检查特殊字符，如<、>、'、"等，如果发现特殊字符，则将这些字符过滤或编码。
比较智能的输入检查，可能还会匹配XSS的特性。比如查找过滤“script”、“javascript”等敏感词。
这种输入检查的方式，可以称为“XSS Filter”。互联网上有很多开源的“XSS Fileter”的实现。
XSS Filter在用户提交数据时获取变量，并进行XSS检查；但此时用户数据并没有结合渲染页面的HTML代码，因此XSS Filter对语境的理解并不完整。
例子。

###输出检查
一般来说，除了富文本的输出外，在变量输出到HTML页面时，可以使用编码或转义的方式来防御XSS攻击。

- 安全的编码函数

编码分很多种，针对HTML代码的编码方式是HtmlEncode。它的作用是将将字符转换成HTMLEntities。
在php中，有htmlentities()和htmlspecialchars()两个函数可以满足安全需求。
相应的，javascript的编码方式可以使用JavascriptEncode。
JavascriptEncode与HtmlEncode 的编码方法不同，它需要使用“\”对特殊字符进行转义。
在对抗XSS时，还需要输出的变量必须在引号内部，以避免造成安全问题。
例子。

除了HtmlEncode、JavascriptEncode外，还有许多用于各种情况的编码函数，比如XMLEncode，JSONEncode。

- 只需要一种编码吗（略）。


###正确的防御XSS
为了更好的设计XSS防御方案，需要认清XSS产生的本质原因。
XSS的本质还是一种“HTML注入”，用户的数据被当成HTML代码一部分来执行，从而混淆了原本的语义，产生了新的语义。
想要根治XSS问题，可以列出所有XSS可能发生的场景，再一一解决。
- 在HTML标签中输出，防御方法是HtmlEncode。
- 在HTML属性中输出，防御方法是HtmlEncode。
- 在script标签中输出，防御方法是JavascriptEncode。
- 在事件中输出，防御方法是JavascriptEncode。
- 在CSS中输出

在CSS和style、style attribute中形成XSS的方式非常多样化。
例子。
所以一般来说，尽可能禁止用户可控制的变量在“style标签”、“HTML标签的style属性”以及“CSS文件”中输出。
如果一定有这样的需求，则推荐使用OWASP ESAPI中的encodeFroCSS()函数。
其实现原理是，除了字母、数字外的所有字符都被编码成十六进制形式“\uHH”。
- 在地址中输出

在地址中输出也比较复杂，一般来说在URL的path（路径）或search（参数）中输出，使用URLEncode即可。
URLEncoede会将字符转换成“%HH“形式，比如空格“%20”，“<”是“%3c”。
但是还有一种情况，就是整个URL能够被用户完全控制。
这时URL的Protocal和Host部分是不能够使用URLEncode的，否则会被改变URL的语义。

例子。

一般来说，如果变量是整个URL，则应该先检查变量是否以“http”开头，如果不是则自动添加，以保证不会出现伪协议类的XSS攻击。
在此以后，再对变量进行URLEncode，即可保证不会有类似的XSS发生了。

###处理富文本
有些时候，网站需要允许用户提交一些自定义的HTML代码，称之为“富文本”。
过滤富文本时，“事件”应该被严格禁止，因为“富文本”的展示需求里不应该包括“事件”这种动态效果。
而一些危险的标签，比如iframe、script、base、form等，也应该严格禁止。
在标签的选择上，应该使用白名单，避免使用黑名单。比如，只允许a、img、div等比较“安全”的标签存在。

“白名单原则”不仅仅用于标签的选择，同样应该用于属性与事件的选择。
在富文本过滤中，处理CSS也是一件麻烦的事情。
如果允许用户自定义CSS、style，则也可能导致XSS攻击。因此尽可能禁止用户自定义CSS与style。
如果一定要允许用户自定义样式，则只能像过滤“富文本”一样过滤“CSS”。
这还需要一个CSS Parser对样式进行只能分析，检查其中是否包含危险代码。

###防御DOM Based XSS
DOM Based XSS是一种比较特殊的XSS漏洞，前文提到的几种防御方法都不太适用，需要特别对待。

正确防御方法是，首先，在“$var”输出到script标签中时，应该执行一次javascriptEncode；
其次，在document.write输出到HTML页面时，要分具体情况看待：
如果是输出到事件或脚本，则要做再做一次javascriptEncode；
如果是输出到HTML内容或属性，则要做一次HtmlEncode。
也就是说，从javascript输出到HTML页面，也相当于一次XSS输出的过程，需要分语境使用不同的编码函数。
会触发DOM Based XSS的地方有很多，以下几个地方是javascript输出到HTML页面的必经之路。
例子。
需要重点关注这几个地方的参数是否可以被用户控制。

除了服务器端直接输出变量到javascript，还有以下几个地方可能会成为DOM Based XSS的输入点，也需要重点关注。
例子。

###换个角度看XSS的风险
前文谈到的所有XSS攻击，都是从漏洞形成的原理上看的。如果从业务风险的角度来看，则会有不同的观点。
在修补XSS漏洞时遇到的最大挑战之一是漏洞数量太多，因此开发者来可能来不及，也不愿意修补这些漏洞。
从业务风险的角度来重新定位每个XSS漏洞，就具有了重要的意义。
